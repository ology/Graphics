#!/usr/bin/env perl
use strict;
use warnings;

# Generate a pseudo-analog clock
# Usage: perl basic-clock > clock.svg
# Hands: black=hour, blue=minute, red=second

use GD::SVG;
use Math::Trig qw(:pi);

use constant PI     => pi;
use constant HALF   => pip2;
use constant DOUBLE => pi2;
use constant FRACT  => 2 * PI / 12 / 60;

# All arguments optional.
my ( $diameter, $hours, $minutes, $seconds ) = @ARGV;

# Set the maximum polar diameter and radius.
$diameter ||= 200;
my $radius = $diameter / 2;

my $clock = GD::SVG::Image->new( $diameter, $diameter );

# Set image properties.
my $trans = $clock->colorAllocate( 200, 200, 200 ); # background
my $red   = $clock->colorAllocate( 255,   0,   0 ); # second hand
my $blue  = $clock->colorAllocate(   0,   0, 255 ); # minute hand
my $black = $clock->colorAllocate(   0,   0,   0 ); # hour hand
$clock->transparent($trans);
$clock->interlaced('true');

# Add the circle to the clock.
$clock->arc( $radius, $radius, $diameter, $diameter, 0, 360, $black );

# Indicate the hours
for my $hour (1 .. 12) {
    my ( $s, $m, $h ) = time_point( 0, 0, $hour );
    $clock->arc( @$h, 6, 6, 0, 360, $black );
}

# Get polar coordinate of the given or current time.
my ( $s, $m, $h ) = time_point( $seconds, $minutes, $hours, 1 );

# Draw the arms of the clock.
$clock->line( $radius, $radius, @$s, $red );    # second hand
$clock->line( $radius, $radius, @$m, $blue );   # minute hand
$clock->line( $radius, $radius, @$h, $black );  # hour hand

# Render the clock.
print $clock->svg;

sub time_point {
    my ( $s, $m, $h, $flag ) = @_;

    # Use the current time if not given.
    ( $s, $m, $h ) = ( localtime )[ 0 .. 2 ]
        unless defined $s && defined $m && defined $h;

    warn sprintf "%02d:%02d:%02d\n", $h, $m, $s;

    # Compute the analog time equivalents.
    $s = $s / 60 * DOUBLE - HALF;
    $m = $m / 60 * DOUBLE - HALF;
    $h = $h / 12 * DOUBLE - HALF;
    # TODO Add 1/2 degree to the next hour mark for each minute
    $h += $m * FRACT if $flag;

    # Replace the time values with polar coordinates.
    $_ = [
        $radius + $radius * cos $_,
        $radius + $radius * sin $_
    ] for $s, $m, $h;

    warn join( ', ', map { sprintf "[%.2f,%.2f]", @$_ } $s, $m, $h ), "\n";

    return $s, $m, $h;
}
