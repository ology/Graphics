#!/usr/bin/perl
use strict;
use warnings;

use GD;
use Math::Trig;

# Define Ï€ based constants.
use constant PI     => 2 * atan2(1,0);
use constant HALF   => PI / 2;
use constant DOUBLE => 2 * PI;

my $max = $ARGV[0] || 100;
my $radius = $max / 2;

#$max++ if $max % 2 == 0;

my $clock = GD::Image->new( $max, $max );

my $trans = $clock->colorAllocate(200,200,200);
my $red   = $clock->colorAllocate(255,0,0);
my $blue  = $clock->colorAllocate(0,0,255);
my $black = $clock->colorAllocate(0,0,0);

$clock->transparent( $trans );
$clock->interlaced( 'true' );
$clock->arc( $radius, $radius, $max, $max, 0, 360, $black );

my( $s, $m, $h ) = time_point();

$clock->line( $radius, $radius, @$s, $red );
$clock->line( $radius, $radius, @$m, $blue );
$clock->line( $radius, $radius, @$h, $black );

print $clock->png;  # Usage: ./clock > clock.png
#pic_output( $clock );

exit;

sub time_point {
  my( $s, $m, $h ) = (localtime)[0..2];
#  printf "%02d:%02d:%02d\n", $h, $m, $s;

  $s = $s / 60 * DOUBLE - HALF;
  $m = $m / 60 * DOUBLE - HALF;
  $h = $h / 12 * DOUBLE - HALF;

  $_ = [$radius + $radius * cos $_, $radius + $radius * sin $_]
    for $s, $m, $h;

#  print join( ', ', map { sprintf "[%.2f,%.2f]", @$_ } $s, $m, $h ), "\n";

  return $s, $m, $h;
}

sub pic_output {
  my $self = shift;
  my $name = 'clock.png';
  binmode STDOUT;
  open F, '>'. $name or die "Can't open $name - $!\n";
  binmode F;
  print F $self->png;
  close F;
}
