#!/usr/bin/env perl
use strict;
use warnings;

# Generate a pseudo-analog clock
# Usage: perl basic-clock > clock.svg
# Hands: black=hour, blue=minute, red=second

use GD::SVG;
use Math::Trig;

use constant PI     => 2 * atan2(1,0);
use constant HALF   => PI / 2;
use constant DOUBLE => 2 * PI;
use constant FRACT  => 5 / 60;

# All arguments optional.
my ( $diameter, $hours, $minutes, $seconds ) = @ARGV;

# Set the maximum polar diameter and radius.
$diameter ||= 200;
my $radius = $diameter / 2;

my $clock = GD::SVG::Image->new( $diameter, $diameter );

# Set image properties.
my $trans = $clock->colorAllocate( 200, 200, 200 ); # background
my $red   = $clock->colorAllocate( 255,   0,   0 ); # second hand
my $blue  = $clock->colorAllocate(   0,   0, 255 ); # minute hand
my $black = $clock->colorAllocate(   0,   0,   0 ); # hour hand
$clock->transparent($trans);
$clock->interlaced('true');

# Add the circle to the clock.
$clock->arc( $radius, $radius, $diameter, $diameter, 0, 360, $black );

# Indicate the hours
#for my $hour (1 .. 12) {
#    my ( $s, $m, $h ) = time_point( 0, 0, $hour );
#    $clock->arc( @$h, 6, 6, 0, 360, $black );
#}

# Get polar coordinate of the given or current time.
my ( $s, $m, $h ) = time_point( $seconds, $minutes, $hours );

# Draw the arms of the clock.
$clock->line( $radius, $radius, @$s, $red );    # second hand
$clock->line( $radius, $radius, @$m, $blue );   # minute hand
$clock->line( $radius, $radius, @$h, $black );  # hour hand

# Render the clock.
print $clock->svg;

sub time_point {
    my ( $s, $m, $h ) = @_;

    # Use the current time if not given.
    ( $s, $m, $h ) = ( localtime )[ 0 .. 2 ]
        unless defined $s && defined $m && defined $h;

    warn sprintf "%02d:%02d:%02d\n", $h, $m, $s;

    # Compute the analog time equivalents.
    $s = $s / 60 * DOUBLE - HALF;
    $m = $m / 60 * DOUBLE - HALF;
    # TODO Add 1/60th of the distance to the next hour mark for each minute
    $h = $h / 12 * DOUBLE - HALF;
#    $h += $m * FRACT if $m > 0;

    # Replace the time values with polar coordinates.
    $_ = [
        $radius + $radius * cos $_,
        $radius + $radius * sin $_
    ] for $s, $m, $h;

    warn join( ', ', map { sprintf "[%.2f,%.2f]", @$_ } $s, $m, $h ), "\n";

    return $s, $m, $h;
}
