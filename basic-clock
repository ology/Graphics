#!/usr/bin/perl
#
# Gnerate a pseudo-analog clock image with Perl.
# -- gene@cpan.org
#
use strict;
use warnings;

# Import the GD graphics library.
use GD;
# Import the trigonometry library.
use Math::Trig;

# Define Ï€ based constants.
use constant PI     => 2 * atan2(1,0);
use constant HALF   => PI / 2;
use constant DOUBLE => 2 * PI;

# Set the maximum polar diameter and radius.
my $max    = $ARGV[0] || 100;
my $radius = $max / 2;

# XXX Why?
#$max++ if $max % 2 == 0;

# Instantiate our clock image.
my $clock = GD::Image->new( $max, $max );

# Set image properties.
my $trans = $clock->colorAllocate(200,200,200);
my $red   = $clock->colorAllocate(255,0,0);
my $blue  = $clock->colorAllocate(0,0,255);
my $black = $clock->colorAllocate(0,0,0);
$clock->transparent($trans);
$clock->interlaced('true');

# Add the circle to the clock.
$clock->arc( $radius, $radius, $max, $max, 0, 360, $black );

# Get polar coordinate of the current time.
my( $s, $m, $h ) = time_point();

# Draw the arms of the clock.
$clock->line( $radius, $radius, @$s, $red );
$clock->line( $radius, $radius, @$m, $blue );
$clock->line( $radius, $radius, @$h, $black );

# Render the clock.
print $clock->png;  # Usage: ./clock > clock.png
#pic_output( $clock );

sub time_point { # Return the current time as polar coordinates.
  # Get the current local time.
  my( $s, $m, $h ) = (localtime)[0..2];
#  printf "%02d:%02d:%02d\n", $h, $m, $s;

  # Compute the analog time equivalents.
  $s = $s / 60 * DOUBLE - HALF;
  $m = $m / 60 * DOUBLE - HALF;
  $h = $h / 12 * DOUBLE - HALF;

  # Replace the time values with polar coordinates.
  $_ = [$radius + $radius * cos $_, $radius + $radius * sin $_]
    for $s, $m, $h;
#  print join( ', ', map { sprintf "[%.2f,%.2f]", @$_ } $s, $m, $h ), "\n";

  return $s, $m, $h;
}

sub pic_output { # Render the analog clock to a PNG file.
  my $name = 'clock.png';
  # Print the image (in "binary mode").
  open my $png, '>', $name or die( "Can't open $name - $!\n" );
  binmode $png;
  print $png $self->png;
  close $png;
}
